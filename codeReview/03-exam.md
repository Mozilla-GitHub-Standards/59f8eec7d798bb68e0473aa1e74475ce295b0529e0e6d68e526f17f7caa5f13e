So - you have a new piece of code, and it passes all the simple checks laid out in the contribution guideline. Now it's time to start examining the code in depth! There are two main areas to consider here: how is the new code itself (*intrinsic* examination), and how does it fit in with the rest of the code (*extrinsic* examination). Remember, code review is a lot like giving feedback, and any feedback exercise benefits from having a list of things to watch out for in hand before you begin.

#### Intrinsic Examination
The first thing to look at, is the quality of the new code on it's own, without worrying about the rest of the project (yet). In time, you will come up with your own list of mistakes you see people making that you'll want to keep an eye out for - but for now, let's start off with some of the classics:

 - **Are the functions modular?** If the contribution consists of new functions, are those functions as simple as possible? For example, if the goal is to sort some data and make a plot, there should be one function that *just* sorts the data, and *another* function that *just* plots the sorted data - **not** one function that does both at once!
 - **Are the functions efficient?** If some really slow operation is performed in the code, is it performed as little as possible? For example, diagonalizing a matrix can be a slow computation. If the new code needs to do a slow operation like this, it should do it once only, and store the result for use, rather than recomputing it every time it needs to use it. Not sure which operations are slow? *Assume they all are!* Don't repeat any operation unnecessarily.
 - **Is usage clear?** Will a new user (or you, a few months from now) easily be able to tell how to use this code? This can often simply mean making sure documentation describes exactly what inputs functions use and what outputs they return.
 - **Have edge cases been considered?** Users will invariably do all kinds of weird stuff with your code that they aren't supposed to. If the user does something unexpected (weird inputs, clicking on things they're not supposed to...), will this new code break, or will it roll with the punches? For example, if a function takes a numerical input, is there a situation where division by 0 be triggered?

#### Extrinsic Examination
Once you're satisfied that your new code is good on it's own, the last step is to decide if it's a good part of the team - does it fit nicely within the existing code? Again, checklists are your friend, and again, you'll build your own with experience, but here are some canonical things everyone should check for.
 - **Does the new code reinvent any wheels?** New code should be just that - *new*. If it's reproducing functionality you have elsewhere in the code, it shouldn't be repeated here. This is one of the main reasons for insisting on splitting functions up into as small of pieces as possible; all their shared components can then be written (and debugged!) just once.
 - **Does the new code fit the project?** If you're writing a program to look for patterns in a genome, it doesn't need a built in music player. Just as a microwave that also mows your lawn would be cumbersome and weird, don't let 'feature creep' bloat your project; keep things focused, and you'll be able to keep maintaining and using the code for years. It can help to insist that all new contributions clearly and specifically address a need or issue that has been previously discussed and agreed upon, either in person, in the repo's issue tracker, or elsewhere, and to make sure the purpose of the project as a whole is clearly defined and limited to the bare necessities.
 - **Does the new code respect the structure of the project?** A healthy project is a well organized project. If the rest of the code has established variable or path naming conventions, file structure, or other patterns, does this new code uphold those patterns?
